---
description: Analyze PR comments (auto-sets up worktree if needed)
argument-hint: [PR-NUMBER or keywords]
scope: global
---

# Review PR Comments

Analyze and categorize PR feedback.

**Arguments:** $ARGUMENTS (optional, flexible)

**Formats:**
- No args: Show PR summary for all your PRs
- Number: `89` - Review specific PR
- Keywords: `latest`, `needs-attention`, `mine`
- Contextual: `latest 4`, `above 2` - Interpret from conversation

---

## GitHub Comment Types

| Type | Source | Resolvable | API |
|------|--------|------------|-----|
| **Review Threads** | Inline code comments | ‚úÖ Yes | GraphQL `reviewThreads` |
| **Batch Comments** | Greptile, Codex, etc. | ‚ùå No | REST `pulls/N/comments` |
| **PR Comments** | General discussion | N/A | REST `issues/N/comments` |

**Review Threads:** Standard code review comments on specific lines. Shows as inline comments. Can be resolved/unresololved via API.

**Batch Comments:** Generated by code review tools (Greptile, Codex). Shows as "Additional Comments (N)" dropdown in GitHub UI. Attached to files/lines but NOT resolvable via API.

**PR Comments:** General discussion on the PR (not attached to code). We ignore these as they're not actionable code feedback.

---

## Instructions

### Step 0: Determine Mode

**If no arguments ‚Üí Show PR Summary for ALL your open PRs**

List all PRs with feedback counts.

**If specific PR number ‚Üí Review that PR**

---

### Step 1: Fetch UNRESOLVED Code Review Comments (Fresh Query, Paginated)

**IMPORTANT:** Always query from scratch (no cached cursor) to catch all comments including newly added ones.

**1a. Helper function - Fetch ALL threads (fresh):**

```bash
REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner')
OWNER=${REPO%%/*}
REPO_NAME=${REPO##*/}

fetch_all_unresolved_threads() {
  ALL_THREADS="[]"
  CURSOR=""

  while true; do
    if [ -z "$CURSOR" ]; then
      RESULT=$(gh api graphql \
        -f owner="$OWNER" \
        -f repo="$REPO_NAME" \
        -F prNumber=$PR_NUM \
        -f query='query($owner: String!, $repo: String!, $prNumber: Int!) { repository(owner: $owner, name: $repo) { pullRequest(number: $prNumber) { title headRefName reviewThreads(first: 100) { pageInfo { hasNextPage endCursor } nodes { id isResolved isOutdated path line comments(first: 10) { nodes { author { login } body createdAt } } } } } } }')
    else
      RESULT=$(gh api graphql \
        -f owner="$OWNER" \
        -f repo="$REPO_NAME" \
        -F prNumber=$PR_NUM \
        -f cursor="$CURSOR" \
        -f query='query($owner: String!, $repo: String!, $prNumber: Int!, $cursor: String!) { repository(owner: $owner, name: $repo) { pullRequest(number: $prNumber) { title headRefName reviewThreads(first: 100, after: $cursor) { pageInfo { hasNextPage endCursor } nodes { id isResolved isOutdated path line comments(first: 10) { nodes { author { login } body createdAt } } } } } } }')
    fi

    PAGE_THREADS=$(echo "$RESULT" | jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)]')
    ALL_THREADS=$(echo "$ALL_THREADS $PAGE_THREADS" | jq -s 'add')

    HAS_NEXT=$(echo "$RESULT" | jq -r '.data.repository.pullRequest.reviewThreads.pageInfo.hasNextPage')
    if [ "$HAS_NEXT" != "true" ]; then break; fi
    CURSOR=$(echo "$RESULT" | jq -r '.data.repository.pullRequest.reviewThreads.pageInfo.endCursor')
  done

  echo "$ALL_THREADS"
}

# Call the function (always fresh)
THREADS=$(fetch_all_unresolved_threads)
```

**1b. Fetch batch review comments (non-resolvable) - paginated:**

```bash
# Get ALL review comments (paginated, 100 per page)
BATCH_COMMENTS=$(gh api "repos/$REPO/pulls/$PR_NUM/comments" --paginate \
  --jq '[.[] | select(.in_reply_to_id == null) | {id, author: .user.login, path, line, body, created_at}]')
```

**Note:** Batch review comments (from code review tools like Greptile, Codex) appear as "Additional Comments (N)" dropdown in GitHub UI. They're attached to files but not resolvable threads.

**What this fetches:**
- ‚úÖ Unresolved review threads (resolvable) - **ALL pages, fresh query**
- ‚úÖ Batch review comments (non-resolvable, "Additional Comments") - **ALL pages**
- ‚úÖ File path and line number
- ‚úÖ All comments in thread (for context)
- ‚ùå Skips resolved threads (saves tokens)
- ‚ùå Skips reply comments (only root comments)

---

### Step 2: Categorize

**üî¥ High:** Security, bugs, ALL human comments
**üü° Medium:** Code quality, bot suggestions
**üü¢ Nice to Have:** Style, docs, nits

**Already filtered out:** Resolved threads (via GraphQL query)
**Ignore:** Bot approvals, emoji-only replies

---

### Step 2.5: Validate & Recommend

For EACH comment, analyze:

1. **Read the code context** - Open the file at the specified line
2. **Assess validity** - Is the comment correct given the actual code?
3. **Check if already addressed** - Has a subsequent commit fixed it?
4. **Determine action** - What should be done?

**Validity Assessment:**
- ‚úÖ **Valid** - Comment is correct, should be fixed
- ‚ö†Ô∏è **Partially Valid** - Has a point but may be overstated
- ‚ùå **Invalid** - Misunderstanding, already fixed, or not applicable
- ü§î **Needs Discussion** - Subjective, requires clarification

**Recommendation Types:**
- **FIX** - Implement the suggested change
- **REPLY** - Explain why current approach is correct
- **ASK** - Request clarification from reviewer
- **SKIP** - Already addressed or not applicable

---

### Step 3: Output

```markdown
# üìù PR #{PR_NUM} Comments

**PR:** [TICKET] Title
**Branch:** {branch_name}

## Comment Types
- Review Threads (resolvable): {N}
- Batch Comments (non-resolvable): {M}

## üî¥ High Priority ({N})
| # | Author | Location | Validity | Action | Comment |
|---|--------|----------|----------|--------|---------|
| 1 | üë§ john-doe | file.tsx:45 | ‚úÖ Valid | FIX | Missing null check |
| 2 | üë§ jane-smith | api.ts:89 | ‚ùå Invalid | REPLY | Already handled by try-catch on line 85 |

## üü° Medium ({N})
| # | Author | Location | Validity | Action | Comment |
|---|--------|----------|----------|--------|---------|
| 3 | ü§ñ propel-bot | utils.ts:12 | ‚ö†Ô∏è Partial | FIX | Extract constant (minor but valid) |

## üü¢ Nice to Have ({N})
| # | Author | Location | Validity | Action | Comment |
|---|--------|----------|----------|--------|---------|
| 4 | ü§ñ lint-bot | types.ts:5 | ‚úÖ Valid | SKIP | Style preference, not blocking |

---

## üìã Recommended Actions

### To Fix (pass to /fix-pr-comments)
```
/fix-pr-comments 1 3
```

### To Reply (need your response)
- **[2]** jane-smith: Explain the try-catch handles this case

### To Discuss (needs clarification)
- None

---

## üéØ Merge Status
{If unresolved = 0:} ‚úÖ READY TO MERGE
{Else:} ‚ùå {N} to fix, {M} to reply ‚Üí /fix-pr-comments 1 3
```

---

## Notes

- **Fresh queries**: Always starts pagination from scratch (no cached cursors)
- **Catches late comments**: New comments added after previous queries are included
- **Pagination support**: Fetches ALL threads/comments (not just first 100)
- **Token optimized**: Uses GraphQL to fetch only unresolved threads
- **Shows comment types**: Distinguishes resolvable threads from batch comments
- **Code comments only**: Skips general PR comments (not actionable)
- **Resolution-aware**: Won't miss latest comments (filters at API level)
- Can review any PR from any workspace (read-only)
- To fix: ensure you're in the correct Conductor workspace for that PR's branch
- Uses `${var%%/*}` syntax to avoid subshell parsing issues
- Uses `--paginate` flag for REST API to get all pages automatically
- Merge ready = all threads resolved (batch comments can't be resolved)
